# Subclass RedBlackTree
Once you've copied over both files from the P13.RBTInsert into the P15.RBTIterator folder, create a new class IterableMultiKeyRBT in the P15.RBTIterator folder that extends your RedBlackTree class and implements the IterableMultiKeySortedCollectionInterface. The new class should be a generic class. Use the following steps to specify the generic types:
Define a new bounded type parameter for the keys we store in IterableMultiKeyRBT. This type should have the same bounds as BinarySearchTree's and RedBlackTree's type parameters.
Specify the type argument for IterableMultiKeySortedCollectionInterface by directly passing on the type parameter of IterableMultiKeyRBT.
Specify the type argument for RedBlackTree. Since the nodes of our tree will store objects of type KeyListInterface, we will use KeyListInterface parameterized with IterableMultiKeyRBT's key type as RedBlackTree's type parameter.
Once you have specified the type parameters, try to compile your IterableMultiKeyRBT class. The only errors you get at this point should be about the 4 unimplemented methods. If there are additional errors, refine your type parameters (steps 1-3).
Import java.util.Iterator in your IterableMultiKeyRBT class since we will use it as the return type of one of its methods.
Next, add the four methods from the IterableMultiKeySortedCollectionInterface to your IterableMultiKeyRBT. Leave the body of these methods empty at first. If a method has a non-void return type, return a hard-coded value, such as null or false. The four methods have detailed javadoc header comments in the IterableMultiKeySortedCollectionInterface. You can copy over those header comments into your IterableMultiKeyRBT class and don't need to add or modify them.
Add at least 3 JUnit test methods within your IterableMultiKeyRBT class. Each test should implement a different test case and check that your extended tree and iterator are working as expected. You can freely choose the test cases you'd like as long as they are not duplicates of each other. You can use the header comments for details on what each of IterableMultiKeyRBT's methods will do once fully implemented. The tests will fail at first, but should pass once you have completed the implementation of the extended tree. Be sure to include javadoc style method header comments for each of the test methods that clearly describe what scenario each method is testing. Also include in-line comments to document the steps of your test code. Submit the IterableMultiKeyRBT class with the three test methods by Monday, Oct 16. If you need to change your tests after the mid-week submission, you are welcome to do so.
Next, we will add two fields to the IterableMultiKeyRBT. One of them to store the iteration start point, which should have the same type that is passed into the setIterationStartPoint method. The second one to store the number of keys in our tree. Since we will insert KeyListInterface objects into the nodes of our tree, the size method of BinarySearchTree will reflect the number of nodes in the tree, and we will need to keep track of the number of keys separately.
Implement the numKeys method that returns the number of keys stored in the tree and the setIterationStartPoint method that sets the start point of the iterator.
Next, override the clear method of the tree. In the new clear method, call the old clear method of BinarySearchTree, then add a line that sets the field that counts the number of keys to zero.
Implement the insertSingleKey method. The method should create a KeyList with the new key, then check if the tree already contains a node with duplicates EDIT 10/16: You can use the findNode method with the KeyList for this. If it does, add the key to the KeyList in the node that contains the duplicates and return false. If it does not, then insert the new KeyList into a new node of the tree and return true.
# Implement the Iterator
Since we won't need access to the color of a node, we can use the Node type of BinarySearchTree for the nodes in our tree, including that Node's up and down fields.
To implement the iterator method, start by creating a new protected helper method called getStartStack that returns an instance of java.util.Stack containing nodes after initialization. If no iteration start point is set (the field that stores the start point is set to null), the stack is initialized with the nodes on the path from the root node to (and including) the node with the smallest key in the tree. If the iteration start point is set, then the stack is initialized with all the nodes with keys equal to or larger than the start point along the path of the search for the start point. This will make sure that the iterator will only visit the nodes that are equal to or greater than the start point by popping those nodes off the stack to visit them and then visit their right subtree afterwards.
During the search for the start point when initializing the stack, you can use the compareTo method of the start point's Comparable type to compare the start point to the first element in each duplicate list. You have access to the first element by calling the .iterator() method of KeyListInterface and then .next() on the returned list iterator.
Use an anonymous class in the iterator method to create a new iterator object and implement its hasNext and next methods. Use the getStartStack method from the previous steps to create the initial stack for the iterator. The iterator should return all keys in the tree, including all duplicates, that are equal to or greater than the set start point, or all keys if no start point is set. The iterator should return them one by one for each call of its next method, in ascending order.
